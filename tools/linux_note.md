## Linux

#### 1 文件目录结构

[Unix目录结构的来历- 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2012/02/a_history_of_unix_directory_structure.html)

最早的Unix系统使用了一种叫做RK05的储存盘，一盘的容量大约是1.5MB，没过多久，操作系统（根目录）变得越来越大，一块盘已经装不下了。于是，他们加上了第二盘RK05，并且**规定第一块盘专门放系统程序，第二块盘专门放用户自己的程序**，因此挂载的目录点取名为/usr。也就是说，根目录"/"挂载在第一块盘，"/usr"目录挂载在第二块盘。除此之外，两块盘的目录结构完全相同，第一块盘的目录（/bin, /sbin, /lib, /tmp...）都在/usr目录下重新出现一次。

后来，第二块盘也满了，他们只好又加了**第三盘**RK05，挂载的目录点取名为/home，并且规定**/usr用于存放用户的程序**，**/home用于存放用户的数据**。

总结，根目录存放系统程序，/usr和/home服务于用户，分别存放用户的程序和数据。

usr:Unix Software Resource

| 目录  | 内容                                               | 举例               |
| ----- | -------------------------------------------------- | ------------------ |
| /bin  | 供**所有用户使用**的完成**基本维护任务的命令**     | ls, cp             |
| /etc  | 系统和应用软件的**配置文件**                       | bashrc, passwd     |
| /home | 普通用户的家目录                                   | /home/msh          |
| /lib  | 系统最基本的共享**链接库和内核模块**               | libc-2.17.so       |
| /root | root用户的家目录                                   | .bashrc, .ssh      |
| /sbin | 超级用户使用的**可执行文件**，里面多是系统管理命令 | ifconfig, iptables |
| /tmp  | 存储临时文件                                       |                    |

`/usr`目录的目录结构与根目录相似，但根目录中的文件多是系统级的文件，而`/usr`目录中是用户级的文件，一般与具体的系统无关。

CentOS 7.2中，`/bin`等所谓“系统级目录”都被软链到了`/usr/bin`等所谓“用户级目录”。其他发行版如Debian可能差别更大。

一般建议将_所有用户共享的软件安装到`/usr/local`目录_（结构与`/usr`目录相似）下，*将用户私有的软件安装到用户自己的家目录*。

[比起 Windows，怎样解读 Linux 的文件系统与目录结构？](https://www.infoq.cn/article/how-to-read-linux-file-system-and-directory-structure)



#### 2 用户管理和权限

[root@zhtHost ~]#:root表示当前用户账号，zhtHost表示主机名，~表示当前所在目录，#是提示符。

~代表用户的主文件夹，root用户的主文件夹在/root，使用~表示/root。user用户的的主文件夹在/home/user,所以当使用user账号登录时，~就表示/home/user。

至于提示符，root用户的提示符是#，一般身份用户的提示符是$。exit退出账号。

**bash**：登录后的命令行操作是在Linux中的bash中进行的，bash是一个命令行终端软件，是Linux下默认的shell。shell的中文是“外壳”，里面是操作系统内核，用户无法直接接触操作系统，必须通过最外层的shell来和系统内核通信。shell的功能是提供给用户一个操作系统的借口，可以调用其他软件，如man，chown，vi,这些独立的应用程序。因此，只要能够操作应用程序的接口都能成为shell。

**权限管理**：Linux中使用用户组和多用户来进行文件的权限管理。一个系统上可以有多个**用户组**，一个用户组中可以有多个**用户**，用户组的作用是在同一用户组的用户们可以共同享有一些文件，其他用户组的成员无法访问。同一用户组的每个用户也可以拥有自己的私有文件，同一组内的其他用户无法访问。任何一个文件都有**“user group other”**3种身份的权限限制。

![1548319077533](D:\note\LearnNote\tools\markdown_image\1548319077533.png)

如上图所示，每个文件说明从左到右依次是：

文件权限——连接——所属用户——所属用户组——文件大小，单位：B——创建或者最后修改日期——文件名（前面带.的表示隐藏文件）。

其中表示文件权限的有10个字母，第一个字母代表文件类型，后面9个分为3组rwx，依次代表user group other的访问权限（所有者、同用户组、非本用户组）。

第一个字母：d：表示文件夹，—：表示文件，l：表示连接文件。b：可供存储接口设备，c：串行接口设备，如键盘、鼠标（一次性读取）。

后面的3组为rwx的组合，r表示可读，read；w可读write，x可以执行。

对文件夹来说，**不具备x执行权限就表示无法进入该文件夹**。

`drwxr-xr-x`dev是一个文件夹，属于root用户组中的root用户，root用户对其可读可写可执行，root组的其他用户对其可读可执行，非root组的用户对其可读可执行。

**Linux 用户的管理**：

su zht：切换到zht用户。

sudo:以root身份执行命令，后面需要输入密码

su为switch user，即切换用户的简写

su - USERNAME切换用户后，同时切换到新用户的工作环境中

su USERNAME切换用户后，不改变原用户的工作目录，及其他环境变量目录

sudo COMMAND 即意为sudo以root用户执行

默认情况下，系统只有root用户可以执行sudo命令。需要root用户通过使用visudo命令编辑sudo的配置文件/etc/sudoers，才可以授权其他普通用户执行sudo命令。

sudo的配置文件为：/etc/sudoers。

sudoers文件中允许指定用户在不需要知道root用户的登陆密码的情况下，可以以root用户身份运行各种命令。此文件必须使用visudo命令编辑配置。



groups:查看当前用户所在的用户组。

使用cat  /etc/group 可以查看本系统上所有的用户组合用户信息。

![1548319262683](D:\note\LearnNote\tools\markdown_image\1548319262683.png)

上面每一行的信息表示的分别是：用户组——用户组口令（密码）——GID——用户组用户列表。

groupadd zhts:添加zhts用户组

groupdel zhts:删除zhts用户组

adduser zht:添加zht用户，会自动生成一个zht用户组，且zht的用户主目录在/home/zht 下。如果之间加 –G groupname 就表示将该用户添加到groupname 用户组去。

passwd zht:给zht用户添加密码，这个一定要添加。



#### 3 常用命令

**tab**：按一下，在命令行第一个命令后表示补全命令，第二个命令后，补全文件。在第一个命令未完成时，按2下，则会显示所有已当前输出内容为开头的命令，即提示所有命令。

**ctrl+c**:停止执行当前命令。即终止命令的执行。强制终止当前进程

**ctrl+ｚ**:强制当前进程转换为后台，并在后台挂起（暂停）。

**ctrl+d**:代表EOF（end of file），等同exit。退出

**clear**:清屏

**man**:帮助命令，如：man ls 输出ls的指令说明，空格翻页，q退出。pgup/pgdn也可以上下翻页。end尾页/home首页。/string（或者?string） 匹配查找string字符，n继续向下查找（next），N继续向上查找。

**pwd**：查看当前路径

**ls**:list 列出目录清单，ls 参数 目录，按照相应的设置参数列出文件目录。如：

**ls** –al  / 列出根目录下的所有文件，包括隐藏的文件，其中 –al 可以省略，没有/ 则表示列出当前路径下的文件目录。

**ll**:ls -l的缩写

**cd**:切换当前路径，cd .. 回到上一级目录，cd / 回到系统根目录，cd path 切换到path目录，cd ~ 切换到当前用户主目录，cd – 返回到此目录之前所在目录。

**mkdir**:新建一个目录

**rmdir**:删除一个空目录，目录下有文件不能删除。

**rm**:删除文件，如果删除带有文件的文件夹，需要-r 参数，递归删除。-f 强制删除，不会出现警告，-i 删除前询问是否要删除。

**mv**：移动文件 mv 源文件  目标文件，也可以更改文件名,mv dir1 dir2修改文件夹名。

**cp**:文件复制，cp 源文件 目标文件

**cat**:查看文档命令 。

**less**：查看文档命令，可以上下翻页。

![1548322830097](C:\Users\geb9wx\AppData\Roaming\Typora\typora-user-images\1548322830097.png)

**chmod**:改变文件权限，如chmod 775 t.txt 将t.txt文件权限修改为所有者同一用户组可读可写可执行，其他用户组可读可执行。快捷的权限修改：

chmod +x t.txt, 为文件添加执行权限。 -x ，去除执行权限。

![1548322887383](C:\Users\geb9wx\AppData\Roaming\Typora\typora-user-images\1548322887383.png)

**wget**:下载文件命令，后接http地址可以下载文件到当前目录下。

PATH:当前用户路径临时设定可以使用`echo $PATH` 来查看，添加PATH路径

`PATH=” $PATH”:/home/zht/temp` 

或者 

`export PATH=$PATH:/home/zht/tmp`

上面的方法只能临时更改path，重启后更改失效。

查看设定的JAE_HOME 使用指令：echo $JRE_HOME

**which**:查看命令所在目录 ，或者使用type

#**whereis**  软件名  -->查看软件安装路径
#**which**  软件名     -->软件软件的运行路径

**find**:查找指令。find 指定目录  指定名字

如：find  /  -name  “java*”  ：最后一个参数不加“”也可以

**touch**：命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。

实例一：创建不存在的文件命令：touch log2012.log log2013.log

实例二：更新log.log的时间和log2012.log时间戳相同

实例三：设定文件的时间戳命令：touch -t 201211142234.50 log.log

**export** 设置或者显示 环境变量

**grep**是Linux命令行下常用于查找过滤文本文件内容的命令。最简单的用法是： 

grep apple fruitlist.txt 

grep会返回“fruitlist.txt”中所有包含“apple”的文本行。要注意的是，grep不会返回匹配“Apple”（A字母大写）的文本行，因为grep默认情况下是大小写敏感的。

如果想忽略大小写，可以用-i参数： 

grep -i apple fruitlist.txt 

如果想搜索目录里所有文件，包括子目录的话，并且在结果中显示行号，可以用以下命令： 

grep -nr apple * 

grep的语法支持正则表达式，正则表达式有些复杂，以后再讲解。

·      -i, --ignore-case: 忽略大小写

·      -n, --line-number: 显示行号

·      -R, -r, --recursive: 递归搜索子目录

·      -v, --invert-match: 输出没有匹配的行

我们可以通过管道操作来让grep变得更强大，**管道操作就是把前面一条命令的输出作为后面一条命令的输入**，从而把很多简单的命令组合起来完成复杂的功能。例如，如果我们想查找包含apple的行，但又想过滤掉pineapple，可以用下面的命令： 

grep apple fruitlist.txt | grep -v pineapple 

如果我们想把搜索结果保存起来，那么可以把命令的标准输出重定向到文件： 

grep apple fruitlist.txt | grep -v pineapple > apples.txt 

**重定向符号>**和**管道操作符号|**的区别是，重定向后面接的是一个文件，它后面不能再接任何文件或命令了；而管道操作后面接的是命令，可以无限地接下 去。如果想以**追加方式**写到文件，可以用**>>**。管道操作是Linux命令行的一种哲学，它是计算机技术中少有的能沿用几十年的技术之一。通过管 道操作，一行命令可以完成Windows下上千行程序也不能完成的文本处理功能。 

**压缩命令**

在Linux中采用gzip和bzig2作为压缩命令，其中bzip2使用的压缩算法相比gzip更加先进，采用gzip命令压缩的文件以.gz为后缀名，采用bzip2压缩的文件以.bz2为文件后缀名。其使用方法是：gzip 参数 待压缩文件名 -v参数常用来显示压缩工程中的压缩比。

压缩：`gzip -v m.java`

解压： `gzip -dv m.java.gz`

bzip2的使用方式和gzip是一样的。

由于gzip和bzip2命令只能针对单一文件进行压缩或解压，所以不能同时对多个文件或文件夹进行压缩，这时就需要使用打包命令tar来进行辅助，tar是将多个文件打包成一个文件的命令，同时在打包的过程中也可以使用压缩算法。如果只是打包不 压缩，则文件后缀名为.tar，如果打包后采用gzip命令压缩，则后缀名为.tar.gz，如果采用bzip2命令压缩，则后缀名为.tar.bz2。

1. 只打包：`tar -cv -f j.jar *.java`

   -c:新建打包文件

   -v:将正在处理的文件名显示出来。

   -f:后面接待处理的文件名，如是打包操作就是打包后生产的新文件名，如果是压缩操作 -f后接的就是压缩后生产的新文件名，如果是解压操作，后面接的是待解压的文件名。很多地方喜欢将-f和前面的参数写在一起，不过还是建议单独写出来。

   最后 *.java表示将所有以.java结尾的文件打包成一个j.tar文件。

2. 

2. 解打包： tar -xv -f j.tar -C ./tmp/

   -x：解打包或者解压缩功能

   -C：待解打包的目录

    -t:查看打包的文件内容，主要用来查看文件名。

   注意，在tar命令，-c -x -t每次只能出现其中的一个。

-j：表示采用bzip2命令对打包的文件进行压缩。
-z：表示采用gzip命令对打包的文件进行压缩。

使用-xzv  -f参数后为待解压缩文件名。最后面-C接解压后的文件存放目录，如果没有-C参数，则默认解压到当前文件夹。另外同-x -v -t同级别的参数还有-r：向压缩文件中追加文件， -u更新压缩包中的指定文件：

使用**pscp** 远程给主机传输文件

pscp  [options]   source    user@ host:target 

`pscp  -pw zht111111 C:\a.txt   root@104.11.22.33:/tmp` 类似于push动作

从linux获取文件，只需要将目标和源反过来即可

`pscp  -pw zht111111  root@104.11.22.33:/tmp  C:\a.txt`  

-p 拷贝文件的时候保留源文件建立的时间。
 -q 执行文件拷贝时，不显示任何提示消息。
 -r 拷贝整个目录
 -v 拷贝文件时，显示提示信息。

-pw passwd 指定登录时所用的口令为 passwd

**ps**命令  常用 `ps -ef`

-e 显示所有进程,环境变量
-f 全格式

a：与终端相关的进程；

x：与终端无关的进程；

u：显示用户

aux：常用组合选项；

**kill** -9 PID ，杀死该PID进程。

**jobs**查看当前作业，

**bg** 1 或者bg %1均可以将对应id为1进程调回前台。



#### 4 shell 脚本

Linux的shell脚本相当于Windows下的.bat批处理文件，并且比批处理更加强大，可以进行变量赋值，流程控制。

第一行：“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。/bin/sh默认链接到bin目录下的bash。#后面接的是注释。 

```shell
vim hello.sh

#!/bin/sh
a="hello world"
echo "a is:"
echo $a

#运行
chmod u+x hello.sh
./hello.sh

```

echo命令用来打印信息，是一个最常用的命令。

-n 打印信息之后不换行。

-e 对字符串转义。

扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。

`/bin/sh hello.sh`

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。

有时候变量名很容易与其他文字混淆，比如：

```sh
num=2

echo "this is the $numnd"
```

这并不会打印出"this is the 2nd"，而仅仅打印"this is the "，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：

num=2

`echo "this is the ${num}nd"`

这将打印： this is the 2nd

由export关键字处理过的变量叫做环境变量。



条件表达式：

**if**  条件表达式   **then** 处理语句

**else** 处理语句

**fi**



使用脚本切换当前路径：

在linux环境下，常有通过shell脚本进入指定目录的操作，例如有一段脚本chdir.sh：     

```sh
#!/bin/sh  

cd /home/user/Downloads  

pwd  
```

在shell环境下通过./chdir.sh执行这段脚本是无法进入Downloads目录的

这是因为shell在执行脚本时，会创建一个子shell，并在子shell中逐个执行脚本中的指令； 而子shell中从父shell中继承了环境变量，但是执行后不会改变父shell的环境变量；

![1548388416635](C:\Users\geb9wx\AppData\Roaming\Typora\typora-user-images\1548388416635.png)

如果想要代码中切换目录的操作生效，只需要通过 source 命令执行即可：

`source  ./chdir.sh`   

​      source 命令是在当前的shell环境下执行脚本 ，不会创建子shell;  

​      每次都要输入source是一件烦琐的事情，其实source命令又叫点命令，在需要用到source的情况下，直接换成'.'即可： 

`.  ./chdir.sh`  

![1548388430559](C:\Users\geb9wx\AppData\Roaming\Typora\typora-user-images\1548388430559.png)

**cat**命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。

cat主要有三大功能：

1.一次显示整个文件:cat filename

2.从键盘创建一个文件:cat > filename 只能创建新文件,不能编辑已有文件.

3.将几个文件合并为一个文件:cat file1 file2 > file



**数据流重定向**

那么什么时数据流重定向呢？从字面上理解就是改变数据流的流向，使之流向指定的文件或设备。

例如，把执行命令所回传的正确信息（标准输出信息）流向一个文 件，而将所回传的错误信息（标准错误输出）流向别一个文件，并把这两个文件的信息保存下来，而在屏幕上不出现任何该命令执行所回传的信息。
格式：
command-line  [1~n] > file： file为或文件操作符或设备
上面命令意思是：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）  重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出。

1.将标准输出重定义，>前面的1代表标准输出，是可以省略的，省略后默认为1。

2.将错误输出重定义

1、 shell遇到”>”操作符，会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。 无论左边命令执行是否成功。右边文件都会变为空。“>>”操作符，数据追加到该文件的末尾。先判断右边文件，如果不存在，先创建。以添加方式打开文件，会分配一个文件描述符[不特别指定，默认为1,2]然后，与左边的标准输出（1）或错误输出（2） 绑定。

当命令：执行完，绑定文件的描述符也自动失效。0,1,2又会空闲。



**test**的用法：
test 命令最短的定义可能是评估一个表达式；如果条件为真，则返回一个 0 值。如果表达式不为真，则返回一个大于 0 的值 — 也可以将其称为假值。检查最后所执行命令的状态的最简便方法是使用 $? 值。

1. 关于某个文件名的『类型』侦测(存在与否)，如 test -e filename  
  -e 该『文件名』是否存在？(常用)  
  -f 该『文件名』是否为文件(file)？(常用)  
  -d 该『文件名』是否为目录(directory)？(常用)  



