#### 设计模式的六大基本原则

1.单一职责原则：一个类只负责一项职责，且只有一个引起它变化的原因。职责太多会影响其复用性，且其中一个职责变化时，可能会影响其他职责的正常运行，所以需要将职责分离，封装在不同的类中。例如：实现界面和逻辑功能分离。

2.里氏替换原则：任何父类出现的地方，都可用替换成其子类，子类可以扩展父类功能，但不能改变父类功能。在定义时尽量使用父类，实际使用时再确定具体的子类，是实现开闭原则的重要方法之一。

3.依赖倒置原则：核心思想是面向接口编程，依赖抽象，而不是依赖具体，相对细节的多变性，抽象要稳定很多，以抽象为基础搭建的框架要比以细节为基础搭建起来的框架稳定得多。要对抽象进行编程，不对实现进行编程，降低客户和具体实现模块之间的耦合。

Java排序Collections.sort()方法传入参数List类型，这样就可以对ArrayList和LinkList分别进行排序实现。

4.接口隔离原则：使用多个功能单一的接口，而不是一个总接口，客户不应该依赖那些它不需要的接口。降低依赖，降低耦合，接口要适度，不能太大或者太小。

其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。

5.迪米特法则：（最少知道原则）一个软件实体应尽量少和其他软件实体进行交互，使得系统功能模块相对独立，这样当一个模块修改后，就会尽量少的影响到其他模块，扩展也会更容易；即一个对象应该对其他对象保持最少的了解。类之间关系越复杂，耦合度越高，一个类改变时，对其他类的影响也越大。一个类应该尽量把逻辑封装在内部，除了对外提供public方法外，不对外泄露任何信息。

低耦合，高内聚，可以通过中间类来降低多个类之间的耦合度。

6.开闭原则：软件应该尽量在不修改原有代码的情况下，进行扩展实现新的功能。对扩展开发，对修改关闭，实现热插拔的效果，便于维护和升级，用抽象构建框架，用实现扩展细节。用抽象搭建框架，用实现扩展细节。

7.组合/聚合复用原则：尽量使用组合和聚合，少用继承来实现类的复用。在新对象里通过关联关系（成员变量）使用一些已有的对象，新的对象通过委派调用已有对象的方法来实现功能复用的目的。



UML表示方法：

https://www.cnblogs.com/scevecn/p/5663369.html



#### 1 策略模式

定义算法族，将变化的算法抽象封装起来，使其之间可以相互替换，对用户来说它是感知不到算法的变化的。

Demo代码：

```
//抽象行为方法接口
interface IFlyBehavior {
	void fly();
}

//具体实现方法
class FlyWithWings implements IFlyBehavior {
	@Override
	public void fly() {
		System.out.println("fly with wings");
	}
}
 class FlyNoWay implements IFlyBehavior {
	 @Override
	public void fly() {
		 System.out.println("fly no way");
	}
 }
 
 abstract class Duck {
	 IFlyBehavior mFlyBehavior;//持有行为接口引用
	 
	 public void setFlyBehavior(IFlyBehavior flyBehavior) {
		 mFlyBehavior = flyBehavior;
	 }
	 
	 public void fly() {
		 mFlyBehavior.fly();//委托给行为类
	 }
 }
```



#### 2 观察者模式

定义了对象之间一对多的依赖，这样一来，当一个对象改变时，它的所以依赖者都会受到通知并自动更新。更新可以被动接受也可以主动持有subject查询。

1个subject，多个observer， observer向subject订阅，subject内部维护了一个List,用来添加或者移除观察者，当subject的数据改变时，就遍历List, 调用observer的接口，通知他们更新数据了。

```
interface Observer {
	void update(Subject sub);//在子类中去主动查询数据，
	或者此处传入需要通知的参数
}

interface Subject {
	public void registerObserver(Observer ob);
	public void removeObserver(Observer ob);
	public void notifyObservers();
}

class SubjectImpl implements Subject {
	List<Observer> observerList = new ArrayList<>();
	
	public void registerObserver(Observer ob) {
		observerList.add(ob);
	}
	
	public void removeObserver(Observer ob) {
		observerList.remove(ob);
	}
	
	public void notifyObservers() {
		for (Observer observer : observerList) {
			observer.update(this);
		}
	}
}
```



#### 3 装饰者模式

动态地将职责附加到对象上，如果要扩展功能，提供了比继承更有弹性的替代方案。

需要满足以下条件：

1. 装饰者和被装饰者继承相同的超类Super，原因：因为装饰者内部持有超类的引用，通过该引用委托调用API，如果装饰者也是Super的子类，那么装饰者就可以去装饰其他的装饰者了。
2. 装饰者持有被装饰者的引用，委托调用其API，装饰者在调用API前后可以添加自己的行为。
3. 装饰者可以无限装饰装饰者或者被装饰者。

```
public class DecoratorDemo {
	public static void main(String[] args) {
		IComponet sub = new ComponetImpl(); //被装饰者
		IComponet decoratorA = new ConcreteDecoratorA(sub);
		decoratorA.fun();
		System.out.println("----------");
		IComponet decoratorB = new ConcreteDecoratorB(decoratorA);
		decoratorB.fun();
	}
	
}

abstract interface IComponet {
	void fun();
}

class ComponetImpl implements IComponet {
	@Override
	public void fun() {
		System.out.println("我是被装饰者");
	}
}

abstract class Decorator implements IComponet {
	IComponet obj;
	public Decorator(IComponet obj) {
		this.obj = obj;
	}
	
	//具体的装饰者子类需要覆盖该方法，在obj.fun()之前或之后加入新的逻辑
	@Override
	public void fun() {
		obj.fun();
	}
}

class ConcreteDecoratorA extends Decorator {
	public ConcreteDecoratorA(IComponet obj) {
		super(obj);
	}

	@Override
	public void fun() {
		System.out.println("我是装饰者，前面添加功能----A");
		obj.fun();
	}
}

class ConcreteDecoratorB extends Decorator {
	public ConcreteDecoratorB(IComponet obj) {
		super(obj);
	}

	@Override
	public void fun() {
		obj.fun();
		System.out.println("我是装饰者，后面添加功能----B");
	}
}


输出结果：
我是装饰者，前面添加功能----A
我是被装饰者
----------
我是装饰者，前面添加功能----A
我是被装饰者
我是装饰者，后面添加功能----B
```



#### 4 工厂模式

1.简单工厂模式

简单工厂其实不算是一个设计模式，而是一种编程习惯，就是把一些对象的创建工作移到另一个对象Factory中，由Factory来专职负责创建类，并处理创建对象的细节，对象的使用客户不关心对象的具体创建过程。

1. 创建对象的方法一般声明为static类，
2. 返回的对象类型通常是基类。